
@page "/KnowledgeBase/Page2"
@inject IJSRuntime JS

<h2>Markdown Editor</h2>

<div id="MainText" @ref="editableDiv" spellcheck="true" @onfocusout="ShowMarkdown" @onfocusin="ShowRaw" @oninput="HandleInput"
     autocorrect="on" autocapitalize="on" translate="no" contenteditable="true" class="cm-content cm-lineWrapping"
     role="textbox" aria-multiline="true" data-language="hypermd" style="tab-size: 4; padding-bottom: 100px;"></div>
<div contenteditable="true"></div>


<script>
    // Capture caret position as the index within the text content
    window.getCaretPosition = function (element) {
        let caretOffset = 0;
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            caretOffset = preCaretRange.toString().length;
        }
        return caretOffset;
    };

    // Restore caret position using the captured offset
    window.setContentAndRestoreCaret = function (element, content, caretPosition) {
        // Set the new content (HTML)
        element.innerHTML = content;

        // Restore caret position based on the saved offset
        let currentPos = 0;
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false);

        let node;
        while ((node = walker.nextNode())) {
            const nodeLength = node.nodeValue.length;

            if (currentPos + nodeLength >= caretPosition) {
                const range = document.createRange();
                const selection = window.getSelection();
                range.setStart(node, caretPosition - currentPos);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
                break;
            }

            currentPos += nodeLength;
        }
    };

    // Extract the plain text content (markdown) from the contenteditable div
    window.getRawTextContent = function (element) {
        return element.innerText; // Return the plain text content
    };
</script>

@code {
    private ElementReference editableDiv;
    private bool isUpdating = false;
    private int caretPosition = 0;
    private string RawContent;

    private async Task HandleInput()
    {
        // Get the raw content of the editor
        RawContent = await JS.InvokeAsync<string>("getRawTextContent", editableDiv);
    }

    private async void ShowMarkdown()
    {
        if (isUpdating)
            return;
        // Flag as updating to prevent recursion
        isUpdating = true;
        
        // Get current caret position
        caretPosition = await JS.InvokeAsync<int>("getCaretPosition", editableDiv);
    
        string htmlContent = MarkdownService.ToHtml(RawContent);
    
        // Update the HTML content while preserving the caret position
        await JS.InvokeVoidAsync("setContentAndRestoreCaret", editableDiv, htmlContent, caretPosition);

        // Allow further updates
        isUpdating = false;
    }

    private async void ShowRaw()
    {
        if (isUpdating)
            return;

        // Flag as updating to prevent recursion
        isUpdating = true;
        
        var caretPosition = await JS.InvokeAsync<int>("getCaretPosition", editableDiv);
        // Update the HTML content while preserving the caret position
        await JS.InvokeVoidAsync("setContentAndRestoreCaret", editableDiv, RawContent, caretPosition);
        
        // Allow further updates
        isUpdating = false;
    }

}