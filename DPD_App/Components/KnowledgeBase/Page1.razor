@page "/"
@page "/KnowledgeBase/Page1"
@inject IJSRuntime JS

<h2>Markdown Editor</h2>

<div style="white-space: pre-line" class="editor" contenteditable="true" @oninput="HandleInput" @ref="editableDiv" @onfocusout="ShowMarkdown" @onfocusin="ShowRaw"></div>
<div style="white-space: pre-line" class="editor" contenteditable="true" ></div>

<script>
    // Capture caret position as the index within the text content
    window.getCaretPosition = function (element) {
        let caretOffset = 0;
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            caretOffset = preCaretRange.toString().length;
        }
        return caretOffset;
    };

    // Restore caret position using the captured offset
    window.setContentAndRestoreCaret = function (element, content, caretPosition) {
        // Set the new content (HTML)
        element.innerHTML = content;

        // Restore caret position based on the saved offset
        let currentPos = 0;
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false);

        let node;
        while ((node = walker.nextNode())) {
            const nodeLength = node.nodeValue.length;

            if (currentPos + nodeLength >= caretPosition) {
                const range = document.createRange();
                const selection = window.getSelection();
                range.setStart(node, caretPosition - currentPos);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
                break;
            }

            currentPos += nodeLength;
        }
    };

    // Extract the plain text content (markdown) from the contenteditable div
    window.getRawTextContent = function (element) {
        return element.innerText; // Return the plain text content
    };
</script>

@code {
    private ElementReference editableDiv;
    private bool isUpdating = false;
    private string RawContent;

    private async Task HandleInput()
    {
        // Get the raw content of the editor
        string rawContent = await JS.InvokeAsync<string>("getRawTextContent", editableDiv);
        RawContent = rawContent;
    }

    private async void ShowMarkdown()
    {
        if (isUpdating)
            return;

        // Flag as updating to prevent recursion
        isUpdating = true;

        // Store the new content
        var caretPosition = await JS.InvokeAsync<int>("getCaretPosition", editableDiv);
    
        string htmlContent = MarkdownConverter.ToHtml(RawContent);
    
        // Update the HTML content while preserving the caret position
        await JS.InvokeVoidAsync("setContentAndRestoreCaret", editableDiv, htmlContent, caretPosition);

        // Allow further updates
        isUpdating = false;
    }

    private async void ShowRaw()
    {
        if (isUpdating)
            return;

        // Flag as updating to prevent recursion
        isUpdating = true;
        
        var caretPosition = await JS.InvokeAsync<int>("getCaretPosition", editableDiv);
        // Update the HTML content while preserving the caret position
        await JS.InvokeVoidAsync("setContentAndRestoreCaret", editableDiv, RawContent, caretPosition);
        
        // Allow further updates
        isUpdating = false;
    }

}